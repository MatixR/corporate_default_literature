---
title: "Literature review of corporate default prediction "
author: "Benjamin Christoffersen"
date: "`r format(Sys.time(), 'Updated on %B %d, %Y')`"
output: 
  function(...) rmarkdown::html_document(..., css=c("css/jquery.dataTables.min.css", "css/style.css")):
    toc: false
---

```{r setup, include=FALSE}
options(scipen = 100, digits = 3)
```

## My rating
My rating is my subject score based on the following criteria:

* Relevance if you are building bankruptcy prediction models
* Large data samples (not just listed firms)
* Non-financial firms since there is a general consensus in the literature that these firms should be modeled separately
* Different models, method etc. 
* Different countries or data sets that are commonly used in literature
* Credit scoring is not considered unless I find the paper relevant to prediction

Details of the rating are explaind in "My review". An NA rating means that I have not yet read the paper/document but it is on my TODO list or that I have read the paper/document but not written a review yet

## Further notes
The word logistic regression will be used both for papers using probit models and logistic regression. The logic is that there is usually little difference in practice between the two

TODO: write explanation for frailty versus contagion

## Review table

```{r load_data, echo = FALSE}
# Read in data
review_data <- read.csv("data/review_data.csv", header = T, sep = ",", quote = '"', 
                        stringsAsFactors = F, fileEncoding = "UTF-8-BOM")
actual_headers <- read.csv("data/review_data.csv", header = F, sep = ",", quote = '"', 
                           stringsAsFactors = F, nrows = 1, fileEncoding = "UTF-8-BOM")

colnames(review_data) <- actual_headers
```

```{r format_data, echo = FALSE}
#####
# Replace the model abbrevations 
model_abb <- read.table("data/model_def", sep = ",", header = F, stringsAsFactors = F)
review_data$Models <- sapply(review_data$Models, function(x){
    ms <- unlist(strsplit(x, ", "))
    ms_match <- match(ms, model_abb[, 1])
    if(any(is.na(ms_match))){
        stop("Could not find ", paste0(
            "'", ms[is.na(ms_match)], "'", collapse = " "))
    }
    paste0(model_abb[ms_match, 2], collapse = "\n")
})

stopifnot(!any(duplicated(review_data$`Article name`)))

#####
# Make url for google scholar search
review_data$g_scholar <-  mapply(
  title = review_data$`Article name`,
  publisher = review_data$Publisher,
  
  function(title, publisher){
    if(publisher != "")
      publisher <- paste0(
        '&as_publication="', gsub("\\ ", "+", publisher), '"')
    paste0(
      'https://scholar.google.com/scholar?as_q=&as_epq="',
      gsub("\\ ", "+", title), '"',  publisher, "&hl=en")
  })

#####
# Order rows by my rating
review_data <- review_data[order(review_data$`My rating (1: best, 5: worst)`), ]

#####
# Formating

# replace linebreaks by br
# We also correct for invalid dash entries
for(s in colnames(review_data)[sapply(review_data, is.character)]){
  review_data[[s]] <- gsub("\\s*\\n\\s*", "\\ \\<br\\> \\",review_data[[s]])
  review_data[[s]] <- gsub("–", "-", review_data[[s]])
}

# Wrap links in "a" tags
for(s in c("g_scholar"))
  review_data[[s]] <- paste0("<a target='_blank' href='", review_data[[s]], "' >Link</a>")
```

```{r make_data_tbl, echo=FALSE,results='asis'}
#####
# Change column order
ord <- c("Article name", "Publisher", "Models", "My rating (1: best, 5: worst)", "My review", "g_scholar", "Data source/set", "Sampling", "Sample size (failure / non-failure)", "Outcome")
stopifnot(all(ord %in% colnames(review_data)))

review_data <- review_data[, match(ord, colnames(review_data))]

#####
# Function to print 
fname <- "tbl_file.html" 
unlink(fname)
f <- file(fname, open = "at")

p <- function(x, lvl = 0, tag, file = f){
  if(missing(tag)){
    pb <- ""
    pa <- ""
  } else {
    pb <- paste0("<", tag, ">")
    pa <- paste0("</", tag, ">")
  }
  
  cat(rep("\t", lvl), pb, x, pa, "\n", sep = "", file = file)
}

# Table tag
p("<!--html_preserve-->")
p('<table id="review_tbl" class="display">')

#####
# Header
p("<thead>", 1)
p("<tr>", 2)
cnames <- colnames(review_data)
cnames_change <- c(
  "My rating (1: best, 5: worst)" = "My rating<br>(1: best, 5: worst)",
  "g_scholar" = "Google scholar query",
  "Sample size (failure / non-failure)" = 
    "Sample size<br>(failure / non-failure)")
stopifnot(all(names(cnames_change) %in% cnames))
cnames[match(names(cnames_change), cnames)] <- unname(cnames_change)

invisible(sapply(cnames, p, lvl = 3, tag = "th"))
p("</tr>", 2)
p("</thead>", 1)

#####
# Content 
p("<tbody>", 1)
invisible(apply(review_data, 1, function(x){
  p("<tr>", 2)
  sapply(x, p, lvl = 3, tag = "td")
  p("</tr>", 2)
}))
p("</tbody>", 1)

# Table tag
p('</table>') 
p("<!--/html_preserve-->")

close(f)

# Print content of file
cat(readLines(fname), sep = "\n")

#####
# Make javascript to make table
jname <- "table.js"
unlink(jname)
f <- file(jname, open = "at")

p("<!--html_preserve-->")
p("<script src='js/jquery.dataTables.min.js'></script>")
p('<script type="text/javascript">')

p('// Sort function for NA from https://datatables.net/forums/discussion/7446/numeric-sort-with-na-in-some-cells')
p("$.fn.dataTableExt.oSort['numeric_ignore_nan-asc'] = function(x,y) {")
p('if (isNaN(x) && isNaN(y)) return ((x < y) ? 1 : ((x > y) ? -1 : 0));', 1)
p('if (isNaN(x)) return 1;', 1)
p('if (isNaN(y)) return -1;', 1)
p("x = parseFloat( x );", 1)
p("y = parseFloat( y );", 1)
p("return ((x < y) ? -1 : ((x > y) ? 1 : 0));", 1)
p("};")

p("$.fn.dataTableExt.oSort['numeric_ignore_nan-desc'] = function(x,y) {")
p("if (isNaN(x) && isNaN(y)) return ((x < y) ? 1 : ((x > y) ? -1 : 0));", 1)
p("if (isNaN(x)) return 1;", 1)
p("if (isNaN(y)) return -1;", 1)
p("x = parseFloat( x );", 1)
p("y = parseFloat( y );", 1)
p("return ((x < y) ? 1 : ((x > y) ? -1 : 0));", 1)
p("};")

p("$(document).ready(function() {")
p("$('#review_tbl').DataTable( {", 1)
p('"scrollY": "600px",', 2)
p('"scrollX": true,', 2)
p('"scrollCollapse": true,', 2)
p(paste0(
  '"order": [[', 
  which(colnames(review_data) == "My rating (1: best, 5: worst)") - 1, 
  ", 'asc']],"), 2)

#####
# Setup columnDefs
columnDefs <- c(
  "Article name" = '"className": "dt-body-left", "width": "18em"', 
  "Publisher" = '"className": "dt-body-left", "width": "10em"', 
  "Models" = '"className": "dt-body-left", "width": "20em"', 
  "My rating (1: best, 5: worst)" = 
    '"className": "dt-body-center", "width": "9em", "type": "numeric_ignore_nan"', 
  "My review" = '"className": "dt-body-left", "width": "40em"', 
  "g_scholar" = '"className": "dt-body-center", "width": "5em"', 
  "Data source/set" = '"className": "dt-body-left", "width": "40em"', 
  "Sampling" = '"className": "dt-body-left", "width": "20em"', 
  "Sample size (failure / non-failure)" = 
    '"className": "dt-body-left", "width": "20em"', 
  "Outcome" = '"className": "dt-body-left", "width": "20em"')

stopifnot(setequal(names(columnDefs), colnames(review_data)))
columnDefs <- columnDefs[match(names(columnDefs), colnames(review_data))]
columnDefs <- 
  paste0('{ "targets": ', 0:(length(columnDefs) - 1), ", ",  columnDefs, ' }')
columnDefs[-length(columnDefs)] <- 
  paste0(columnDefs[-length(columnDefs)], ", ")

p('"columnDefs": [', 2)
invisible(sapply(columnDefs, p, 3))
p(']', 2)


p("});", 1)
p("} );")

p('</script>')
p("<!--/html_preserve-->")

close(f)

# Print content of file
cat(readLines(jname), sep = "\n")

# # Order columns and define alignment
# align_n_c_order <- c(
#   "Article name" = "left", 
#   "My rating (1: best, 5: worst)" = "right", 
#   "Citations" = "right", 
#   "Google Scholar" = "right",
#   "abstract" = "left",
#   "year" = "right", 
#   "link" = "left",
#   "My review" = "left", 
#   "Outcome" = "left", 
#   "Sample size (failure / non-failure)" = "left",
#   "Models" = "left", 
#   "Data source/set" = "left", 
#   "Sampling" = "left",
#   "Publisher" = "left")
# 
# split_cells <- c(
#   "Article name" = 25, 
#   "My rating (1: best, 5: worst)" = 20, 
#   "Citations" = 10, 
#   "abstract" = 50,
#   "My review" = 50, 
#   "Outcome" = 50, 
#   "Sample size (failure / non-failure)" = 20,
#   "Models" = 25, 
#   "Data source/set" = 50, 
#   "Sampling" = 50,
#   "year" = 4, 
#   "Publisher" = 20,
#   "link" = 50, 
#   "Google Scholar" = 50)
# 
# review_data <- 
#   review_data[, names(align_n_c_order)]
# row.names(review_data) <- NULL
# 
# # Final formating of header 
# review_data <- plyr::rename(review_data, c(
#   "My rating (1: best, 5: worst)" = "My rating<br>(1: best, 5: worst)",
#   "Sample size (failure / non-failure)" = "Sample size<br>(failure / non-failure)"
# ))
# 
# # Replace line breaks with br tags
# is_char <- sapply(review_data, is.character)
# review_data[, is_char] <- 
#   sapply(review_data[, is_char], gsub, pattern = "\\s*\\n\\s*",
#          replacement = "\\ \\<br\\> \\")
# 
# # We also correct for invalid dash entries
# review_data[, is_char] <- 
#   sapply(review_data[, is_char], gsub, pattern = "–",
#          replacement = "-")
# 
# # Print table
# pander::panderOptions('knitr.auto.asis', FALSE)
# pander::pandoc.table(review_data,
#                      keep.line.breaks = T, 
#                      justify = align_n_c_order, 
#                      split.table = Inf,
#                      split.cells = split_cells[names(align_n_c_order)],
#                      style = 'multiline')
```